/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */



#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif
#include "LIB/BIT_MATH/BIT_MATH.h"
#include "LIB/STD_TYPES/Std_Types.h"

#include "MCAL/GPIO/GPIO_Interface.h"
#include "MCAL/RCC/RCC_Interface.h"
#include "MCAL/NVIC/NVIC_Interface.h"
#include "MCAL/UART/UART_Interface.h"
#include "MCAL/STK/STK_Interface.h"
#include "MCAL/RTC/RTC_Interface.h"

#include "HAL/ESP32/ESP32_Interface.h"
#include "HAL/STEPPER_MOTOR/MOTORS_Interface.h"
#include "HAL/ADS1115/ADC.h"
#include "HAL/PWRSupply/HPWRSupply_Interface.h"

#include "APP/SCommands/SCommands_Interface.h"
#include "APP/SPECTRO/SPECTRO_Interface.h"
#include "APP/Signal_Conditioning/signal_conditioning.h"
#include "APP/SpectroStatus/SpectroStatus_Interface.h"


int main(void)
{
	/////////////////////////////////////////////////
	/////////////////////////////////////////////////
	//SPECTRO_InitSoftware();

	//MGPIO_SetPinValue(MGPIO_PORTA, MGPIO_PIN9, MGPIO_HIGH);

	//HMOTOR_GoHome(HMOTOR_WL_SELECT);
	//HMOTOR_GoHome(HMOTOR_LAMP_SELECT);


	SPECTRO_InitSystem();

	//HMOTOR_GoHome(HMOTOR_WL_SELECT);
	//SPECTRO_Status_t Loc_uint32SpectroStatus = ERROR_INITIALIZING;
	//uint32 Loc_uint32MotorSteps = 0;
	//SpectroStatus_GetCurrentStatus(&Loc_uint32SpectroStatus);
//
	//if(Loc_uint32SpectroStatus == IDLE)
	//{
	//	HMOTOR_MoveWLSelectMotor(1000);
	//	HMOTOR_GetCurrentMotorSteps(HMOTOR_WL_SELECT, &Loc_uint32MotorSteps);
	//	MUART_SendIntegerValue(UART3, Loc_uint32MotorSteps);
	//	MUART_TxChar(UART3, '\n');
//
	//	HMOTOR_MoveWLSelectMotor(500);
	//	HMOTOR_GetCurrentMotorSteps(HMOTOR_WL_SELECT, &Loc_uint32MotorSteps);
	//	MUART_SendIntegerValue(UART3, Loc_uint32MotorSteps);
	//	MUART_TxChar(UART3, '\n');
//
	//	HMOTOR_MoveWLSelectMotor(900);
	//	HMOTOR_GetCurrentMotorSteps(HMOTOR_WL_SELECT, &Loc_uint32MotorSteps);
	//	MUART_SendIntegerValue(UART3, Loc_uint32MotorSteps);
	//	MUART_TxChar(UART3, '\n');
	//}
	//MSTK_uint8Delay(3000);
	////	//MGPIO_SetPinValue(MGPIO_PORTA, MGPIO_PIN9, MGPIO_HIGH);
	////  MGPIO_SetPinValue(MGPIO_PORTB, MGPIO_PIN14, MGPIO_HIGH);
	////	HMOTOR_Step(HMOTOR_WL_SELECT, 85, HMOTORS_CLKWISE_DIRECTION, 6);
		//HMOTOR_GoHome(HMOTOR_LAMP_SELECT);
		//HMOTOR_GoHome(HMOTOR_FILTER_SELECT);
		//HMOTOR_GoHome(HMOTOR_WL_SELECT);
	////
	////	HMOTOR_MoveLampMotor(HMOTOR_LAMP_VIS);
	////
	////	//float32 Loc_float32Ref[2] = {0.0};
	////	float32 Loc_float32Gain = 0.0;
	////
	////
	//uint32 Loc_uint32Index = 0;
	////	float32 de7k[120] = {0.0};
	////	//uint32 de7keteen[33] = {0.0};
	////
	////	adc_init();
	////	HMOTOR_Step(HMOTOR_WL_SELECT, 77, HMOTORS_CLKWISE_DIRECTION, 20);
	////	for(Loc_uint32Index = 0; Loc_uint32Index < 120; Loc_uint32Index++)
	////	{
	////		MUART_SendIntegerValue(UART3, Loc_uint32Index);
	////		MUART_TxChar(UART3, ':');
	////		MUART_TxChar(UART3, ' ');
	////		//read_reference_voltage(&de7k[0][index], &Loc_float32Gain[0]);
	////		read_sample_voltage(&de7k[Loc_uint32Index], &Loc_float32Gain);
	////		HESP32_SendDetectorValues(&de7k[Loc_uint32Index], &Loc_float32Gain);
	////		//HMOTOR_GetCurrentMotorSteps(HMOTOR_WL_SELECT, &de7keteen[Loc_uint32Index]);
	////		HMOTOR_Step(HMOTOR_WL_SELECT, 1, HMOTORS_CLKWISE_DIRECTION, 20);
	////		MSTK_uint8Delay(50);
	////
	////	}
	//    float32 Loc_uint32StepsPerNm = 0;
	//	HMOTOR_Step(HMOTOR_WL_SELECT, 100, HMOTORS_CLKWISE_DIRECTION, 10);
	//	HMOTOR_GoHome(HMOTOR_LAMP_SELECT);
	//	HMOTOR_GoHome(HMOTOR_FILTER_SELECT);
	//	HMOTOR_GoHome(HMOTOR_WL_SELECT);

	//	//turn on visible lamp
	//    HPWRSupply_SetSupplyMode(HPWRSUPPLY_VIS_SUPPLY, HPWRSUPPLY_ON);
	//	HMOTOR_MoveLampMotor(HMOTOR_LAMP_VIS);
	//	//HMOTOR_MoveFilterMotor(HMOTOR_FILTER_AIR);
	//
	//	//Zero Wavelength
	//	uint32 Loc_uint32Index = 0, Loc_uint32Gain = 0;
	//    float32 Loc_uint32WhiteLightIntensities[33] = {0};

	//	uint32 Loc_uint32ZeroWLSteps = 0;
	//	HMOTOR_Step(HMOTOR_WL_SELECT, 77, HMOTORS_CLKWISE_DIRECTION, 10);
	//    adc_init();
	//	for(Loc_uint32Index = 0; Loc_uint32Index < 33; Loc_uint32Index++)
	//	{
	//		read_sample_voltage(&Loc_uint32WhiteLightIntensities[Loc_uint32Index], &Loc_uint32Gain);
	//        //HMOTOR_GetCurrentMotorSteps(HMOTOR_WL_SELECT, &Loc_uint32WhiteLightSteps[Loc_uint32Index]);
	//        HESP32_SendDetectorValues(&Loc_uint32WhiteLightIntensities[Loc_uint32Index], &Loc_uint32Gain);
	//        HMOTOR_Step(HMOTOR_WL_SELECT, 1, HMOTORS_CLKWISE_DIRECTION, 10);
	//        MSTK_uint8Delay(50);
	//	}
	//	uint32 Loc_uint32MiddleStepIndex = Medium_Step_Index(Loc_uint32WhiteLightIntensities, 33);
	//	Loc_uint32ZeroWLSteps = 77 + Loc_uint32MiddleStepIndex;
	//    MUART_TxString(UART3, "Zero Wavelength Steps = ");
	//    MUART_SendIntegerValue(UART3, Loc_uint32ZeroWLSteps);
	//    MUART_TxChar(UART3, '\n');
	//    HPWRSupply_SetSupplyMode(HPWRSUPPLY_VIS_SUPPLY, HPWRSUPPLY_OFF);
	//    HPWRSupply_SetSupplyMode(HPWRSUPPLY_UV_SUPPLY, HPWRSUPPLY_ON);
	//	HMOTOR_MoveLampMotor(HMOTOR_LAMP_UV);
	//		HMOTOR_Step(HMOTOR_WL_SELECT, 33, HMOTORS_CCLKWISE_DIRECTION, 10);
	//		HMOTOR_Step(HMOTOR_WL_SELECT, Loc_uint32MiddleStepIndex, HMOTORS_CLKWISE_DIRECTION, 10);
	//    HMOTOR_Step(HMOTOR_WL_SELECT, 1000, HMOTORS_CLKWISE_DIRECTION, 10);
	//uint32 middle_step = Medium_Step_Index(de7k, 33);
	//MUART_SendIntegerValue(UART3, middle_step);
	//MUART_TxChar(UART3, '\n');
	//HMOTOR_Step(HMOTOR_WL_SELECT, 33, HMOTORS_CCLKWISE_DIRECTION, 20);
	//HMOTOR_Step(HMOTOR_WL_SELECT, middle_step, HMOTORS_CLKWISE_DIRECTION, 20);

	//	//for(Loc_uint32Index = 0; Loc_uint32Index < 20; Loc_uint32Index++)
	//	//{
	//		MUART_SendIntegerValue(UART3, Loc_uint32Index);
	//		MUART_TxChar(UART3, ':');
	//		MUART_TxChar(UART3, ' ');
	//		//read_reference_voltage(&de7k[0][index], &Loc_float32Gain[0]);
	//		read_sample_voltage(&de7k[Loc_uint32Index], &Loc_float32Gain);
	//		HESP32_SendDetectorValues(&de7k[Loc_uint32Index], &Loc_float32Gain);
	//		HMOTOR_Step(HMOTOR_WL_SELECT, 1, HMOTORS_CLKWISE_DIRECTION, 20);
	//		MSTK_uint8Delay(50);
	//
	//	}
	//	HMOTOR_Step(HMOTOR_WL_SELECT, 20, HMOTORS_CCLKWISE_DIRECTION, 20);
	//	for(Loc_uint32Index = 0; Loc_uint32Index < 20; Loc_uint32Index++)
	//	{
	//		MUART_SendIntegerValue(UART3, Loc_uint32Index);
	//		MUART_TxChar(UART3, ':');
	//		MUART_TxChar(UART3, ' ');
	////		read_reference_voltage(&de7k[0][index], &Loc_float32Gain[0]);
	//		read_sample_voltage(&de7k[Loc_uint32Index], &Loc_float32Gain);
	//		HESP32_SendDetectorValues(&de7k[Loc_uint32Index], &Loc_float32Gain);
	//		HMOTOR_Step(HMOTOR_WL_SELECT, 1, HMOTORS_CCLKWISE_DIRECTION, 20);
	//		MSTK_uint8Delay(50);
	//
	//	}
	//HMOTOR_Step(HMOTOR_WL_SELECT, 2500, HMOTORS_CLKWISE_DIRECTION, 10);
	//for(Loc_uint32Index = 0; Loc_uint32Index < 3500; Loc_uint32Index++)
	//{
	//MUART_SendIntegerValue(UART3, (Loc_uint32Index + 2500));
	//MUART_TxChar(UART3, ':');
	//MUART_TxChar(UART3, ' ');
	//read_reference_voltage(&Loc_float32Ref[0], &Loc_float32Gain[0]);
	//read_sample_voltage(&Loc_float32Ref[1], &Loc_float32Gain[1]);
	//HESP32_SendDetectorValues(Loc_float32Ref, Loc_float32Gain);
	//HMOTOR_Step(HMOTOR_WL_SELECT, 1, HMOTORS_CLKWISE_DIRECTION, 20);
	//MSTK_uint8Delay(50);

	//}
	//	float32 de7k[120] = {0.0};
	//	float32 gain = 0.0;
	//	uint8 Loc_de7k;
	//	uint32 middle_step = 0;
	//	float32 reading = 0.0;
	//	float32 max = 0.0;
	//	uint32 max_index = 0;
	//	//	adc_init();
	//	//	HMOTOR_Step(HMOTOR_WL_SELECT, 60, HMOTORS_CLKWISE_DIRECTION, 10);
	//	//	HMOTOR_Step(HMOTOR_WL_SELECT, middle_step, HMOTORS_CLKWISE_DIRECTION, 10);
		//HPWRSupply_SetSupplyMode(HPWRSUPPLY_UV_SUPPLY, HPWRSUPPLY_OFF);
		//HPWRSupply_SetSupplyMode(HPWRSUPPLY_VIS_SUPPLY, HPWRSUPPLY_OFF);
	//	HMOTOR_GoHome(HMOTOR_LAMP_SELECT);
	//	HMOTOR_MoveLampMotor(HMOTOR_LAMP_VIS);
	//	adc_init();
	//	//HMOTOR_Step(HMOTOR_WL_SELECT, 77, HMOTORS_CLKWISE_DIRECTION, 10);
	////	MUART_SendIntegerValue(UART3, 0);
	////	MUART_TxChar(UART3, ':');
	////	MUART_TxChar(UART3, ' ');
	////	read_reference_voltage(&reading, &gain);
	////	HESP32_SendDetectorValues(&reading, &gain);
	//		for(Loc_uint32Index = 0; Loc_uint32Index < 120; Loc_uint32Index++)
	//					{
	//						MUART_SendIntegerValue(UART3, Loc_uint32Index);
	//						MUART_TxChar(UART3, ':');
	//						MUART_TxChar(UART3, ' ');
	//						read_reference_voltage(&de7k[Loc_uint32Index], &gain);
	//						//read_sample_voltage(&Loc_float32Ref[1], &Loc_float32Gain[1]);
	//						HESP32_SendDetectorValues(&de7k[Loc_uint32Index], &gain);
	//						HMOTOR_Step(HMOTOR_WL_SELECT, 1, HMOTORS_CLKWISE_DIRECTION, 10);
	//						MSTK_uint8Delay(50);
	//					}
	//			middle_step = (Medium_Step_Index(de7k, 120));
	//			MUART_SendIntegerValue(UART3, middle_step);
	//			MUART_TxChar(UART3, '\n');
	//				HPWRSupply_SetSupplyMode(HPWRSUPPLY_VIS_SUPPLY, HPWRSUPPLY_OFF);
	//			HPWRSupply_SetSupplyMode(HPWRSUPPLY_UV_SUPPLY, HPWRSUPPLY_ON);
	//			HMOTOR_MoveLampMotor(HMOTOR_LAMP_UV);
	//			HMOTOR_Step(HMOTOR_WL_SELECT, 780, HMOTORS_CLKWISE_DIRECTION, 10);
	//					MUART_SendIntegerValue(UART3, 0);
	//										MUART_TxChar(UART3, ':');
	//										MUART_TxChar(UART3, ' ');
	//										read_reference_voltage(&reading, &gain);
	//										HESP32_SendDetectorValues(&reading, &gain);
	//										read_sample_voltage(&reading, &gain);
	//										HESP32_SendDetectorValues(&reading, &gain);
	//										max = reading;
	//										//adc_init();
	//				for(Loc_uint32Index = 1; Loc_uint32Index < 600; Loc_uint32Index++)
	//							{
	//								MUART_SendIntegerValue(UART3, Loc_uint32Index);
	//								MUART_TxChar(UART3, ':');
	//								MUART_TxChar(UART3, ' ');
	//								read_reference_voltage(&reading, &gain);
	//								HESP32_SendDetectorValues(&reading, &gain);
	//								HMOTOR_Step(HMOTOR_WL_SELECT, 1, HMOTORS_CLKWISE_DIRECTION, 10);
	//								MSTK_uint8Delay(50);
	//								if(reading > max)
	//								{
	//									max = reading;
	//									max_index = Loc_uint32Index;
	//								}
	//							}
	//						MUART_SendIntegerValue(UART3, (max_index + 900));
	//							MUART_TxChar(UART3, '\n');
	//read_sample_voltage(&reading, &gain);
	//HESP32_SendDetectorValues(&reading, &gain);
	//max = reading;
	//adc_init();
	//	for(Loc_uint32Index = 1; Loc_uint32Index < 120; Loc_uint32Index++)
	//	{
	//		MUART_SendIntegerValue(UART3, Loc_uint32Index);
	//		MUART_TxChar(UART3, ':');
	//		MUART_TxChar(UART3, ' ');
	//		read_reference_voltage(&reading, &gain);
	//		HESP32_SendDetectorValues(&reading, &gain);
	//		//read_sample_voltage(&reading, &gain);
	//		//HESP32_SendDetectorValues(&reading, &gain);
	//		HMOTOR_Step(HMOTOR_WL_SELECT, 1, HMOTORS_CLKWISE_DIRECTION, 10);
	//		MSTK_uint8Delay(50);
	//
	//		MUART_SendIntegerValue(UART3, max_index);
	//			MUART_TxChar(UART3, '\n');
	//		if(reading > max)
	//		{
	//			max = reading;
	//			max_index = Loc_uint32Index;
	//		}
	//	}

	//HMOTOR_Step(HMOTOR_WL_SELECT, 500, HMOTORS_CCLKWISE_DIRECTION, 10);
	while(1)
	{
				//HMOTOR_Step(HMOTOR_FILTER_SELECT, 600, HMOTORS_CLKWISE_DIRECTION, 20);
				//MSTK_uint8Delay(500);
				//HMOTOR_Step(HMOTOR_FILTER_SELECT, 600, HMOTORS_CCLKWISE_DIRECTION, 20);
				//MSTK_uint8Delay(500);
		//HMOTOR_Step(HMOTOR_WL_SELECT, 86, HMOTORS_CLKWISE_DIRECTION, 10);
		//MSTK_uint8Delay(500);

		//MSTK_uint8Delay(500);

		//MSTK_uint8Delay(2000);
		//HMOTOR_Step(HMOTOR_WL_SELECT, 30, HMOTORS_CCLKWISE_DIRECTION, 10);
		//read_reference_voltage(&Loc_float32Ref[0], &Loc_float32Gain[0]);
		//read_sample_voltage(&Loc_float32Ref[1], &Loc_float32Gain[1]);
		//HESP32_SendDetectorValues(Loc_float32Ref, Loc_float32Gain);
		//MSTK_uint8Delay(2000);
		//HMOTOR_Step(HMOTOR_WL_SELECT, 15, HMOTORS_CLKWISE_DIRECTION, 10);


		//HMOTOR_Step(HMOTOR_FILTER_SELECT, 1500, HMOTORS_CLKWISE_DIRECTION, 10);
		//HMOTOR_Step(HMOTOR_FILTER_SELECT, 1500, HMOTORS_CCLKWISE_DIRECTION, 10);
		//MSTK_uint8Delay(500);
		//HMOTOR_Step(HMOTOR_WL_SELECT, 1, HMOTORS_CLKWISE_DIRECTION, 10);
		//read_reference_voltage(&Loc_float32Ref, &Loc_float32Gain);
		//read_sample_voltage(&Loc_float32Sample, &Loc_float32Gain);
		//MSTK_uint8Delay(100);
	}
	return 0;
}
